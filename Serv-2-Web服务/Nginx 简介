离开业务不调优
cache is king

pv  两亿 每日日 page view
active connection 100W 活动连接数
qps 1-2 W

qps 每秒的请求数

MPM 是apache2 引入的一个概念，就是将结构模块化，
把核心任务作为一个可插拔的模块，即MPM，使其能针对不同环境进行优化

在这种情况下就诞生了处理模式的概念
处理模式分为 prefork worker event

prefork 适用于有突发的情况下
  #实现了一个非线程的 预派生的web服务器
worker
  #事先生成多少个进程 每个进程多少个线程  全占满是饱和状态  #适合平稳的没有太大波动的业务
event
  #worker 模式的变种，他把服务进程从连接中分离出来，
  在开启keepAlive场合下相对worker模式能够承受的了更高的并发负载


  apache select 和 nginx epoll 有什么区别

阻塞 blocking IO  #一直等 一个进程响应
非阻塞 noblocking IO #不用一直等 但要经常过来看
多路IO multiplexing #多个进程响应 #（多个炉）
异步 asynchronous IO #处理完有通知
事件驱动 singal driven IO


nginx 优点
1.高并发连接 官方测试5W并发 实际能跑2-3W并发
2.内存消耗少：在3W 并发连接下，开启的10个Nginx
  进程才消耗150M 内存 （15M*10=150M）。
3.配置文件非常简单：
  风格跟程序一样通俗易懂
4.成本低廉:Nginx 为开源软件，可以免费使用。
  而购买F5 BIG IP NETScaler 等硬件负载均衡交换机
  则需要十多万至几十万人民币。
5.支持Rewrite重写规则：
  能够根据域名 url的不同将http请求分到不同的后端服务器群组
6.内置的健康检查功能：
  如果Nginx Proxy 后端的某台Web 服务器宕机了 不会影响前端访问。
7.节省带宽：
  支持gzip压缩，可以添加浏览器本地缓存的Header 头
8.稳定性高：
  用于反向代理，宕机的概率微乎其微。
9.模块化设计:
  模块可以动态编译
10.外围支持好：
  文档全 二次开发模块较多
11.支持热部署：
  可以不停机重载配置文件
12.支持事件驱动、AIO、mmap等性能优化


---
主配置文件

#user  nobody; #以哪个用户运行
worker_processes  1; #工作进程数 通常比cpu核心少1 #避免上进程切换消耗资源

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info; #错误日志级别

#pid        logs/nginx.pid; #指定nginx守护进程的pid文件


events {
    worker_connections  1024;
}


http {
    include       mime.types; #包含其他配置文件
    default_type  application /octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html/wordpress;
            index  index.html index.htm index.php;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        location ~ \.php$ {
            root           /usr/local/nginx/html/wordpress;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
	    #fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi_params;
        }

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
